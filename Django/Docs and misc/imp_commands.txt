1) To run server in specific port:
python manage.py runserver 4000

2) Function based view
from django.http import HttpResponse
def my_func(request):
    return HttpResponse('Hello World!')
Now go to urls.py of main project:
from app1 import views
path('api/',views.my_func,name='my_func') # by default same name as view func

3) To remove funcion based views name conflict of multiple apps in urls:
in urls.py:
M1: using aliasing
    from myapp1 import views
    from myapp2 import views
It will take last one. To manage name conflict use aliasing.
    from myapp1 import views as v1
    from myapp2 import views as v2

M2: Using selective imports as:
    from myapp1.views import my_func, home
    from myapp2.views import f2
    path('api/', my_func, name='my_func') # no views.my_func needed

4) To give same response from multiple urls:
path('api/',my_func),
path('a/',my_func)

5) Url path: path('api/', view, kwargs, name) #kwargs and name are optional

use of kwargs: To send values from urls.py kwargs to views.py as:

urls.py:
    path('a/', views.my_func, {'status':'OK'} ,name='my_func'),
app1/views.py:
    def my_func(request, **kwargs):
    status = kwargs.get('status', 'if_ab_then_this_default_val_will_be_shown)
    return HttpResponse(f'Hello World! The status is {status}')
key: dict: mp.get(key_val, default_val_to_return_if_key_is_absent)

6) To write urls.py inside app1 then map to main project's urls.py:
api/urls.py:
from django.urls import path
from .views import my_func
urlpatterns = [
    path('a/', my_func, {'status':'OK'} ,name='my_func'),
]
outer project/urls.py:
from django.urls import path, include
path('inner/', include('api.urls')),
 so urls will be: inner/a

7) Templates for UI:
M1: creating templates inside app1:

inside app1: create templates/app1/django.html
views.py:
# render combines result of given html and variables from the dictionary 
and gives back in text form which is then returned by return that is why
return render.

from djnago.shortcuts import render
def my_func(request):
    return render(request, template_name, context=dict_name, content_type=MIME_type, status= None, 
    using= None)
eg:
def my_func(req):
    return render(req, 'api/django.html')

M2:

8) Render Dynamic template
key: double {{}} inside djnago.html
views.py:
def my_func(request):
    my_var = {'my_key': 12}
    return render(request, 'api/django.html', context=my_var)

djnago.html:
<body>
    <h1>Page num {{my_key}}</h1>
</body>

9) Comment in DTL:
{% comment %} hello this is comment in DTL {% endcomment %}

10) How to use static files; css, js, images
No modifications in settings.py needed if we are creating inside our app1
app1/static/app1/css/style.css
in djnago.html chnages to be made as:
below !doctype write: {% load static %}
include css as above <title> </title>: 
<link rel="stylesheet" href="{% static 'api/css/style.css' %}">

similarly make folder of js , images etc
in djnago.html inculde js above body tage as:
<scripts src="{% static 'api/js/test.js' %}"></scripts>
for images: make img folder and do inside django.html as:
<img src="{% static 'api/img/pic1.png' %}" alt="" >

11) html section like navbar.html let us name it as base.html which stays
constant across all pages, so how do we extend it?
extends is used. you can refer its syntax.

12) Model and create database 
models.py:
from djnago.db imports models
class Profile(models.Model): #Profile will be table name in db with little tweak
    name=models.CharField(max_length=70) # CharField is data type;
# similarly many datatype like for integer, images etc are there in django.
the table name in db is: app1_profile
after this: python manage.py makemigrations: this is used to detect what
chnages we have done in our models.py

to see the corresponding sql command used: assuming migration file is:
0001_initial.py:
python manage.py sqlmigrate app1 0001

to finally make table in db: python manage.py migrate

You made table now you added a new column so you must provide some default
values for the earlier created rows. How to do it as:
M1: select 1 in terminal; type anything like 'bksc'
M2: via code change in models.py as:
    comment = models.CharField(max_length=70, default='my_default_text')

13) To show data from the db:
ModelClassName.objects.all() -> returns the query set which contains all the 
object of this ModelClassName, that is all rows from table.

views.py:
from api.models import Profile # Profile is class name in models.py
def my_func(req):
    stu = Profile.objects.all()
    # to get a single object/row from table:
    v = Profile.objects.get(surname='Kumar')
    print(v.comment)

14) To create superuser: python manage.py createsuperuser

15) To register our model in admi panel:
admin.py:
from api.models import Profile
admin.site.register(Profile)

To make the row data human redable:
in models.py: 
class Profile(models.Model):
    name=models.CharField(max_length=70)
    comment=models.CharField(max_length=70)
    surname=models.CharField(max_length=40,default='Raj')
    def __str__(self):
        return self.name # this you need to add.
        # or if you want id then must typecast it to string as id is int
        # return str(self.id)

# To see db in table form custiomized to our need:
admin.py:
class ProfileAdmin(admin.ModelAdmin):
    list_display = ('name','comment')
admin.site.register(Profile,ProfileAdmin)

advantage: to see data we will not be needing 3rd party editor like sq lite 

another way to do same but using decorate as:
@admin.site.register(Profile)
class ProfileAdmin(admin.ModelAdmin):
    list_display = ('name','comment')

16) To create form, there are two methods:
M1: via form api
M2: via model form

M1: via form api:
create app1/forms.py:
from django import forms
class Registration(forms.Form):
    first_name = forms.CharField(max_length=30) # underscore chnage to space
    email = forms.EmailField()
views.py:
from app1.forms import Registration
def reg(req):
    fm = Registration()
    mp = {'form':fm}
    return render(req, app1/django.html,mp)

17) To hide the password so it looks like dot dot:
in models.py:
class Profile:
    pwd = forms.CharField(widget=forms.PasswordInput())
# similarly: widget=forms.HiddenInput() is also there

18) Use get in frontend whe you want to send data which is small or which
cannot manipulate our backend . like search feature.
use post: when you want to send a data that can manipulate backend.
like: password, token etc. If we use post method then we get protection
from csrf in django.

19) To send data via POST from frontend form in template/app1/django.html)
to backend:
method=post in frontend and after filling values you submit, you get 
csrf verification failed error. How to solve that as:
in djnago.html in you post form write:
{% csrf_token %} below form tag

Now after filling form, how to get this data in backend: (data from f to b)

views.py:
from app1.forms import Registration
def register(request):
    if request.method=='POST':
        f = Registration(request.POST)
        if f.is_valid():
            print(f.cleaned_data)
    else:
        f = Registration()
    return render(request,'api/django.html',{'form':f})

To remove multiple form submission on refreshing the page:
The best option is to redirect to success.html page as:
make success.html inside api/templates
views.py:
from django.http import HttpResponseRedirect
def register(request):
    if request.method=='POST':
        f = Registration(request.POST)
        if f.is_valid():
            print(f.cleaned_data)
            return HttpResponseRedirect('/d') #newly added; also /d is imp;
    else:
        f = Registration()
    return render(request,'api/django.html',{'form':f})

def registration_success(request):
    return render(request, 'api/success.html')

api/urls.py:
path('d/', registration_success)

20) To write our own validation inside forms.py:
class Registration(forms.Form):
    name=forms.CharField()
    def clean_name(self):
        name_value=self.cleaned_data['name']
        if len(name_value)<4:
            raise forms.ValidationError('Enter more than 4 character')
        return name_value

21) To save frontend data of form in db:
as per the parameters of forms.py make models.py params as:
class User(models.Model):
    name=models.CharField(max_length=255)
    email=models.EmailField(max_length=255)
# note: name,email was also in forms.py so be consisitent

views.py:
from api.models import User
def register(request):
    if request.method=='POST':
        f = Registration(request.POST)
        if f.is_valid():
            #print(f.cleaned_data)
            nm = f.cleaned_data['name']
            em = f.cleaned_data['email']
            u = User(name=nm, email=em)
            u.save()
            return HttpResponseRedirect('/d')
# to delete:
u = User(id=2)
u.delete()
 
To save , update, delete we will prefer Model form as in 22

22) Model form ; M2 of 16
forms.py:
from app1.models import User
class Registration(forms.ModelForm):
    class Meta:
        model=User
        fields=['name','email']

23) dynamic url like: api/1; api/2 etc;
urls.py:
from api.views import profile
path('profile/<my_id>', profile, name='profile')
more data type to write:
path('profile/<int:my_id>', profile, name='profile')
path('profile/<slug:title>', profile, name='profile')
path('profile/<str:title>', profile, name='profile')
like: api/django-like-me

api/views.py:
def profile(request,my_id):
    stu = {'id':my_id}
    return render(request, 'api/profile.html', stu)

24)